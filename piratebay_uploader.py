#!/usr/bin/env python3

# upload torrents to thepiraetbay.org

# based on
# https://github.com/genericclient/genericclient-aiohttp/raw/master/genericclient_aiohttp/__init__.py
# https://old.reddit.com/r/learnpython/comments/12ershy/how_to_maintain_a_single_aiohttp_session_for_all/



import os
import re
import sys
import json
import uuid
import asyncio

import aiohttp
import aiohttp_socks
import aiohttp_retry



# TODO update
# generated by docs/categories.json.py
upload_categories = {
    "Audio": {
        "Music": 101,
        "Audio books": 102,
        "Sound clips": 103,
        "FLAC": 104,
        "Other": 199
    },
    "Video": {
        "Movies": 201,
        "Movies DVDR": 202,
        "Music videos": 203,
        "Movie clips": 204,
        "TV shows": 205,
        "Handheld": 206,
        "HD - Movies": 207,
        "HD - TV shows": 208,
        "3D": 209,
        "CAM/TS": 210,
        "UHD/4k - Movies": 211,
        "UHD/4k - TV shows": 212,
        "Other": 299
    },
    "Applications": {
        "Windows": 301,
        "Mac": 302,
        "UNIX": 303,
        "Handheld": 304,
        "IOS (iPad/iPhone)": 305,
        "Android": 306,
        "Other OS": 399
    },
    "Games": {
        "PC": 401,
        "Mac": 402,
        "PSx": 403,
        "XBOX360": 404,
        "Wii": 405,
        "Handheld": 406,
        "IOS (iPad/iPhone)": 407,
        "Android": 408,
        "Other": 499
    },
    "Porn": {
        "Movies": 501,
        "Movies DVDR": 502,
        "Pictures": 503,
        "Games": 504,
        "HD - Movies": 505,
        "Movie clips": 506,
        "UHD/4k - Movies": 507,
        "Other": 599
    },
    "Other": {
        "E-books": 601,
        "Comics": 602,
        "Pictures": 603,
        "Covers": 604,
        "Physibles": 605,
        "Other": 699
    }
}



def get_category_id(name):
    a, b = name.split(">")
    a = a.strip()
    b = b.strip()
    if not a in upload_categories:
        return
    if not b in upload_categories[a]:
        return
    return upload_categories[a][b]

def get_category_name(id):
    id = int(id)
    for a in upload_categories:
        for b in upload_categories[a]:
            if upload_categories[a][b] == id:
                return f"{a} > {b}"

def print_categories():
    for a in upload_categories:
        for b in upload_categories[a]:
            id = upload_categories[a][b]
            print(f"{id} = {a} > {b}")



import datetime
def get_datetime_str():
    # https://stackoverflow.com/questions/2150739/iso-time-iso-8601-in-python#28147286
    return datetime.datetime.utcnow().strftime("%Y%m%dT%H%M%S.%fZ")



class LoginError(Exception):
    pass

class UploadError(Exception):
    pass



class PiratebayUploader:

    """a client for thepiraetbay.org with focus on uploading torrents"""

    def __init__(
            self,
            username,
            password,
            tor_user=None,
            # the default system-wide tor proxy
            tor_host="127.0.0.1",
            tor_port=9050,
        ):

        self.username = username
        self.password = password
        if not tor_user:
            # random username to get a new tor circuit (tor identity)
            tor_user = str(uuid.uuid4())
        self.proxy_url = f"socks5://{tor_user}@{tor_host}:{tor_port}"
        self.base_url = "http://piratebayo3klnzokct3wt5yyxb2vpebbuyjl7m623iaxmqhsd52coid.onion"
        self.clearnet_base_url = "https://thepiratebay.org"

    async def __aenter__(self):

        connector = aiohttp_socks.ProxyConnector.from_url(self.proxy_url)

        # TODO cache the cookies in ~/.cache/piratebay_uploader/cookies.json
        self.cookie_jar = aiohttp.CookieJar(quote_cookie=False)

        self.headers = {
            "Accept": "*",
        }

        self.session = aiohttp.ClientSession(
            connector=connector,
            cookie_jar=self.cookie_jar,
            headers=self.headers,
        )

        self.client = aiohttp_retry.RetryClient(self.session, retry_attempts=10)

        return self

    async def __aexit__(self, *args, **kwargs):

        if not self.session.closed:
            await self.session.__aexit__(*args, **kwargs)

    async def login(
            self,
            username=None,
            password=None,
        ):

        # TODO retry requests on "502 Bad Gateway"

        # TODO check if we are already logged in
        # what is the duration of a login session? 1 hour? 1 day?

        username = username or self.username
        password = password or self.password
        assert username and password, "login requires username and password"

        url = self.base_url + "/session/"

        # docs/forms/login.html

        data = dict(
            username=username,
            password=password,
            act="login",
        )

        async with self.client.post(url, data=data) as response:

            html = await response.text()

            if response.status != 200 or not '<h1><label id="toptxt">Welcome back' in html:

                errors = re.findall('<font color="red">(.*?)</font>', html, re.S)

                errors = list(map(lambda s: s.strip(), errors))

                raise LoginError(" ".join(errors))

            print("login ok")

    async def upload_torrent(
            self,
            torrent_file,
            description,
            category="Other > Other",
            anonymous=False,
        ):

        # validate input

        category_id = None
        if isinstance(category, int) or (
                isinstance(category, str) and re.fullmatch("[0-9]+", category)
            ):
            category_id = category
            category_name = get_category_name(category_id)
            if category_name is None:
                raise ValueError(f"invalid category id {category!r}")
        elif isinstance(category, str):
            category_id = get_category_id(category)
            if category_id is None:
                raise ValueError(f"invalid category name {category!r}")

        # TODO validate the torrent file
        # for example, the title must not be longer than 80 chars (or 80 bytes)
        # https://forum.suprbay.org/Thread-ThePirateBay-Error-Upload-error4?pid=401482#pid401482

        max_torrent_file_size = 1024 * 1024 # 1 MiB

        torrent_file_size = os.path.getsize(torrent_file)

        if torrent_file_size > max_torrent_file_size:
            print(f"warning: torrent file is too large. {torrent_file_size} > {max_torrent_file_size}. probably the upload will fail")

        if isinstance(description, str):
            description = description.strip()

        if not description:
            raise ValueError("empty description")

        # TODO check maximum size of description

        await self.login()

        # docs/forms/upload.html

        data = dict(
            cate=str(category_id),
            desc=description,
            act="upload",
            torrent=open(torrent_file, "rb"),
        )

        if anonymous:
            data["anon"] = "anon"

        url = self.base_url + "/session/"

        result_url = None

        async with self.client.post(url, data=data) as response:

            # TODO check for positive result
            # redirect to description page
            # https://thepiratebay.org/description.php?id=75584652

            html = await response.text()

            errors = re.findall('<font color="red">(.*?)</font>', html, re.S)

            errors = list(map(lambda s: s.strip(), errors))

            if response.status != 200 or len(errors) > 0:

                print("upload Status:", response.status)
                print("upload Content-type:", response.headers["content-type"])
                print("upload errors:", errors)
                print("upload body:", html)

                raise UploadError(" ".join(errors))

            # debug: manually check upload errors
            html_path = f"piratebay_uploader.py.upload.{get_datetime_str()}.html"
            print("writing", html_path)
            with open(html_path, "w") as f:
                f.write(html)

            result_url = str(response.url)
            result_path = result_url[len(self.base_url):]

            # check result_url
            # expected path: /description.php?id=12345
            if not result_path.startswith("/description.php?"):
                raise UploadError(f"unexpected result_url {result_url!r}")

        # replace onion url with clearnet url
        result_url = self.clearnet_base_url + result_path

        print("upload ok:", result_url)

        #print("upload body:", html)


async def main():

    import argparse

    parser = argparse.ArgumentParser()

    # TODO allow to read login from file
    parser.add_argument("-u", "--username")

    parser.add_argument("-p", "--password")

    # TODO also allow magnet link
    parser.add_argument("-f", "--torrent-file")

    parser.add_argument("-d", "--description")

    parser.add_argument("-c", "--category", default="Other > Other")

    parser.add_argument("--list-categories", action="store_true")

    parser.add_argument("-a", "--anonymous", action="store_true")

    # by default, we use the system-wide tor proxy at 127.0.0.1:9050
    #parser.add_argument("--start-tor", action="store_true")

    args = parser.parse_args()

    if args.list_categories:
        return print_categories()

    if not args.torrent_file:
        print("error: torrent file is required")
        print()
        parser.print_help()
        sys.exit(1)

    if not args.description:
        print("error: description is required")
        print()
        parser.print_help()
        sys.exit(1)

    # read config from ~/.config/piratebay_uploader/config.json
    config = dict()
    config_path = os.environ["HOME"] + "/.config/piratebay_uploader/config.json"
    if os.path.isfile(config_path):
        print(f"reading config from {config_path!r}")
        with open(config_path, "r") as f:
            config = json.load(f)

    username = args.username
    password = args.password

    if not (username and password):
        username = config["username"]
        password = config["password"]

    kwargs = dict(
        username = username,
        password = password,
    )

    description = args.description
    if os.path.isfile(description):
        print(f"reading description from {description!r}")
        with open(description, "r") as f:
            description = f.read()

    async with PiratebayUploader(**kwargs) as uploader:

        await uploader.upload_torrent(
            args.torrent_file,
            description,
            args.category,
            args.anonymous,
        )



if __name__ == "__main__":

    asyncio.run(main())
